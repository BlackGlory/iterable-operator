import { IterableOperator } from '@style/chaining/iterable-operator'

test('IterableOperator', () => {
  const expectedMethods = [
    'constructor'

  , 'chunkBy'
  , 'chunk'
  , 'concat'
  , 'dropRight'
  , 'dropUntil'
  , 'drop'
  , 'filter'
  , 'flattenBy'
  , 'flattenDeep'
  , 'flatten'
  , 'map'
  , 'repeat'
  , 'slice'
  , 'splitBy'
  , 'split'
  , 'takeRight'
  , 'takeUntil'
  , 'take'
  , 'tap'
  , 'toAsyncIterable'
  , 'transform'
  , 'uniqBy'
  , 'uniq'
  , 'zip'

  , 'chunkByAsync'
  , 'concatAsync'
  , 'dropUntilAsync'
  , 'filterAsync'
  , 'flattenByAsync'
  , 'mapAsync'
  , 'splitByAsync'
  , 'takeUntilAsync'
  , 'tapAsync'
  , 'transformAsync'
  , 'uniqByAsync'
  , 'zipAsync'

  , 'consume'
  , 'each'
  , 'every'
  , 'find'
  , 'first'
  , 'includes'
  , 'match'
  , 'reduce'
  , 'some'
  , 'last'
  , 'toArray'
  , 'toSet'
  , 'count'
  , 'groupBy'

  , 'eachAsync'
  , 'everyAsync'
  , 'findAsync'
  , 'reduceAsync'
  , 'someAsync'
  , 'groupByAsync'
  ].sort()

  const actualMethods = Object.getOwnPropertyNames(IterableOperator.prototype).sort()

  expect(expectedMethods).toEqual(actualMethods)
})
